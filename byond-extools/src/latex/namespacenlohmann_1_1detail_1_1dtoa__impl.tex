\hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl}{}\doxysection{nlohmann\+::detail\+::dtoa\+\_\+impl Namespace Reference}
\label{namespacenlohmann_1_1detail_1_1dtoa__impl}\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}


implements the Grisu2 algorithm for binary to decimal floating-\/point conversion.  


\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}}
\item 
struct \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power}{cached\+\_\+power}}
\item 
struct \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a1c5d30eb51e5e994a3f48bde104d2ce8}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a1c5d30eb51e5e994a3f48bde104d2ce8}} 
{\footnotesize template$<$typename Target , typename Source $>$ }\\Target {\bfseries reinterpret\+\_\+bits} (const Source source)
\item 
{\footnotesize template$<$typename Float\+Type $>$ }\\\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}} \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}{compute\+\_\+boundaries}} (Float\+Type value)
\item 
\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power}{cached\+\_\+power}} \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}{get\+\_\+cached\+\_\+power\+\_\+for\+\_\+binary\+\_\+exponent}} (int e)
\item 
int \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}{find\+\_\+largest\+\_\+pow10}} (const std\+::uint32\+\_\+t n, std\+::uint32\+\_\+t \&pow10)
\item 
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a5bc841e0bee12fd6489d49cf7bd07bb4}} 
void {\bfseries grisu2\+\_\+round} (char $\ast$buf, int len, std\+::uint64\+\_\+t dist, std\+::uint64\+\_\+t delta, std\+::uint64\+\_\+t rest, std\+::uint64\+\_\+t ten\+\_\+k)
\item 
void \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}{grisu2\+\_\+digit\+\_\+gen}} (char $\ast$buffer, int \&length, int \&decimal\+\_\+exponent, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\+\_\+minus, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} w, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} M\+\_\+plus)
\item 
void \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633}{grisu2}} (char $\ast$buf, int \&len, int \&decimal\+\_\+exponent, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\+\_\+minus, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} v, \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}} m\+\_\+plus)
\item 
{\footnotesize template$<$typename Float\+Type $>$ }\\void \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b}{grisu2}} (char $\ast$buf, int \&len, int \&decimal\+\_\+exponent, Float\+Type value)
\item 
J\+S\+O\+N\+\_\+\+H\+E\+D\+L\+E\+Y\+\_\+\+R\+E\+T\+U\+R\+N\+S\+\_\+\+N\+O\+N\+\_\+\+N\+U\+LL char $\ast$ \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}{append\+\_\+exponent}} (char $\ast$buf, int e)
\begin{DoxyCompactList}\small\item\em appends a decimal representation of e to buf \end{DoxyCompactList}\item 
J\+S\+O\+N\+\_\+\+H\+E\+D\+L\+E\+Y\+\_\+\+R\+E\+T\+U\+R\+N\+S\+\_\+\+N\+O\+N\+\_\+\+N\+U\+LL char $\ast$ \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9}{format\+\_\+buffer}} (char $\ast$buf, int len, int decimal\+\_\+exponent, int min\+\_\+exp, int max\+\_\+exp)
\begin{DoxyCompactList}\small\item\em prettify v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_ac1ea1316de0b4a219f707c76b1db1966}} 
constexpr int {\bfseries k\+Alpha} = -\/60
\item 
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a4a750fcc38da1ce68b7e25ab3a230e20}} 
constexpr int {\bfseries k\+Gamma} = -\/32
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
implements the Grisu2 algorithm for binary to decimal floating-\/point conversion. 

This implementation is a slightly modified version of the reference implementation which may be obtained from \href{http://florian.loitsch.com/publications}{\texttt{ http\+://florian.\+loitsch.\+com/publications}} (bench.\+tar.\+gz).

The code is distributed under the M\+IT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see\+:

\mbox{[}1\mbox{]} Loitsch, \char`\"{}\+Printing Floating-\/\+Point Numbers Quickly and Accurately with
    Integers\char`\"{}, Proceedings of the A\+CM S\+I\+G\+P\+L\+AN 2010 Conference on Programming Language Design and Implementation, P\+L\+DI 2010 \mbox{[}2\mbox{]} Burger, Dybvig, \char`\"{}\+Printing Floating-\/\+Point Numbers Quickly and Accurately\char`\"{}, Proceedings of the A\+CM S\+I\+G\+P\+L\+AN 1996 Conference on Programming Language Design and Implementation, P\+L\+DI 1996 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!append\_exponent@{append\_exponent}}
\index{append\_exponent@{append\_exponent}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{append\_exponent()}{append\_exponent()}}
{\footnotesize\ttfamily J\+S\+O\+N\+\_\+\+H\+E\+D\+L\+E\+Y\+\_\+\+R\+E\+T\+U\+R\+N\+S\+\_\+\+N\+O\+N\+\_\+\+N\+U\+LL char$\ast$ nlohmann\+::detail\+::dtoa\+\_\+impl\+::append\+\_\+exponent (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



appends a decimal representation of e to buf 

\begin{DoxyReturn}{Returns}
a pointer to the element following the exponent. 
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
-\/1000 $<$ e $<$ 1000 
\end{DoxyPrecond}


Definition at line 13559 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13560 \{}
\DoxyCodeLine{13561     assert(e > -\/1000);}
\DoxyCodeLine{13562     assert(e <  1000);}
\DoxyCodeLine{13563 }
\DoxyCodeLine{13564     \textcolor{keywordflow}{if} (e < 0)}
\DoxyCodeLine{13565     \{}
\DoxyCodeLine{13566         e = -\/e;}
\DoxyCodeLine{13567         *buf++ = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{13568     \}}
\DoxyCodeLine{13569     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13570     \{}
\DoxyCodeLine{13571         *buf++ = \textcolor{charliteral}{'+'};}
\DoxyCodeLine{13572     \}}
\DoxyCodeLine{13573 }
\DoxyCodeLine{13574     \textcolor{keyword}{auto} k = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(e);}
\DoxyCodeLine{13575     \textcolor{keywordflow}{if} (k < 10)}
\DoxyCodeLine{13576     \{}
\DoxyCodeLine{13577         \textcolor{comment}{// Always print at least two digits in the exponent.}}
\DoxyCodeLine{13578         \textcolor{comment}{// This is for compatibility with printf("\%g").}}
\DoxyCodeLine{13579         *buf++ = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{13580         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{13581     \}}
\DoxyCodeLine{13582     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (k < 100)}
\DoxyCodeLine{13583     \{}
\DoxyCodeLine{13584         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{13585         k \%= 10;}
\DoxyCodeLine{13586         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{13587     \}}
\DoxyCodeLine{13588     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13589     \{}
\DoxyCodeLine{13590         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 100);}
\DoxyCodeLine{13591         k \%= 100;}
\DoxyCodeLine{13592         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k / 10);}
\DoxyCodeLine{13593         k \%= 10;}
\DoxyCodeLine{13594         *buf++ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + k);}
\DoxyCodeLine{13595     \}}
\DoxyCodeLine{13596 }
\DoxyCodeLine{13597     \textcolor{keywordflow}{return} buf;}
\DoxyCodeLine{13598 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!compute\_boundaries@{compute\_boundaries}}
\index{compute\_boundaries@{compute\_boundaries}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{compute\_boundaries()}{compute\_boundaries()}}
{\footnotesize\ttfamily template$<$typename Float\+Type $>$ \\
\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1boundaries}{boundaries}} nlohmann\+::detail\+::dtoa\+\_\+impl\+::compute\+\_\+boundaries (\begin{DoxyParamCaption}\item[{Float\+Type}]{value }\end{DoxyParamCaption})}

Compute the (normalized) diyfp representing the input number \textquotesingle{}value\textquotesingle{} and its boundaries.

\begin{DoxyPrecond}{Precondition}
value must be finite and positive 
\end{DoxyPrecond}


Definition at line 12818 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{12819 \{}
\DoxyCodeLine{12820     assert(std::isfinite(value));}
\DoxyCodeLine{12821     assert(value > 0);}
\DoxyCodeLine{12822 }
\DoxyCodeLine{12823     \textcolor{comment}{// Convert the IEEE representation into a diyfp.}}
\DoxyCodeLine{12824     \textcolor{comment}{//}}
\DoxyCodeLine{12825     \textcolor{comment}{// If v is denormal:}}
\DoxyCodeLine{12826     \textcolor{comment}{//      value = 0.F * 2\string^(1 -\/ bias) = (          F) * 2\string^(1 -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{12827     \textcolor{comment}{// If v is normalized:}}
\DoxyCodeLine{12828     \textcolor{comment}{//      value = 1.F * 2\string^(E -\/ bias) = (2\string^(p-\/1) + F) * 2\string^(E -\/ bias -\/ (p-\/1))}}
\DoxyCodeLine{12829 }
\DoxyCodeLine{12830     static\_assert(std::numeric\_limits<FloatType>::is\_iec559,}
\DoxyCodeLine{12831                   \textcolor{stringliteral}{"internal error: dtoa\_short requires an IEEE-\/754 floating-\/point implementation"});}
\DoxyCodeLine{12832 }
\DoxyCodeLine{12833     constexpr \textcolor{keywordtype}{int}      kPrecision = std::numeric\_limits<FloatType>::digits; \textcolor{comment}{// = p (includes the hidden bit)}}
\DoxyCodeLine{12834     constexpr \textcolor{keywordtype}{int}      kBias      = std::numeric\_limits<FloatType>::max\_exponent -\/ 1 + (kPrecision -\/ 1);}
\DoxyCodeLine{12835     constexpr \textcolor{keywordtype}{int}      kMinExp    = 1 -\/ kBias;}
\DoxyCodeLine{12836     constexpr std::uint64\_t kHiddenBit = std::uint64\_t\{1\} << (kPrecision -\/ 1); \textcolor{comment}{// = 2\string^(p-\/1)}}
\DoxyCodeLine{12837 }
\DoxyCodeLine{12838     \textcolor{keyword}{using} bits\_type = \textcolor{keyword}{typename} std::conditional<kPrecision == 24, std::uint32\_t, std::uint64\_t >::type;}
\DoxyCodeLine{12839 }
\DoxyCodeLine{12840     \textcolor{keyword}{const} std::uint64\_t bits = reinterpret\_bits<bits\_type>(value);}
\DoxyCodeLine{12841     \textcolor{keyword}{const} std::uint64\_t E = bits >> (kPrecision -\/ 1);}
\DoxyCodeLine{12842     \textcolor{keyword}{const} std::uint64\_t F = bits \& (kHiddenBit -\/ 1);}
\DoxyCodeLine{12843 }
\DoxyCodeLine{12844     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_denormal = E == 0;}
\DoxyCodeLine{12845     \textcolor{keyword}{const} diyfp v = is\_denormal}
\DoxyCodeLine{12846                     ? diyfp(F, kMinExp)}
\DoxyCodeLine{12847                     : diyfp(F + kHiddenBit, static\_cast<int>(E) -\/ kBias);}
\DoxyCodeLine{12848 }
\DoxyCodeLine{12849     \textcolor{comment}{// Compute the boundaries m-\/ and m+ of the floating-\/point value}}
\DoxyCodeLine{12850     \textcolor{comment}{// v = f * 2\string^e.}}
\DoxyCodeLine{12851     \textcolor{comment}{//}}
\DoxyCodeLine{12852     \textcolor{comment}{// Determine v-\/ and v+, the floating-\/point predecessor and successor if v,}}
\DoxyCodeLine{12853     \textcolor{comment}{// respectively.}}
\DoxyCodeLine{12854     \textcolor{comment}{//}}
\DoxyCodeLine{12855     \textcolor{comment}{//      v-\/ = v -\/ 2\string^e        if f != 2\string^(p-\/1) or e == e\_min                (A)}}
\DoxyCodeLine{12856     \textcolor{comment}{//         = v -\/ 2\string^(e-\/1)    if f == 2\string^(p-\/1) and e > e\_min                (B)}}
\DoxyCodeLine{12857     \textcolor{comment}{//}}
\DoxyCodeLine{12858     \textcolor{comment}{//      v+ = v + 2\string^e}}
\DoxyCodeLine{12859     \textcolor{comment}{//}}
\DoxyCodeLine{12860     \textcolor{comment}{// Let m-\/ = (v-\/ + v) / 2 and m+ = (v + v+) / 2. All real numbers \_strictly\_}}
\DoxyCodeLine{12861     \textcolor{comment}{// between m-\/ and m+ round to v, regardless of how the input rounding}}
\DoxyCodeLine{12862     \textcolor{comment}{// algorithm breaks ties.}}
\DoxyCodeLine{12863     \textcolor{comment}{//}}
\DoxyCodeLine{12864     \textcolor{comment}{//      -\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (A)}}
\DoxyCodeLine{12865     \textcolor{comment}{//         v-\/            m-\/            v             m+            v+}}
\DoxyCodeLine{12866     \textcolor{comment}{//}}
\DoxyCodeLine{12867     \textcolor{comment}{//      -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/  (B)}}
\DoxyCodeLine{12868     \textcolor{comment}{//                       v-\/     m-\/     v             m+            v+}}
\DoxyCodeLine{12869 }
\DoxyCodeLine{12870     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} lower\_boundary\_is\_closer = F == 0 and E > 1;}
\DoxyCodeLine{12871     \textcolor{keyword}{const} diyfp m\_plus = diyfp(2 * v.f + 1, v.e -\/ 1);}
\DoxyCodeLine{12872     \textcolor{keyword}{const} diyfp m\_minus = lower\_boundary\_is\_closer}
\DoxyCodeLine{12873                           ? diyfp(4 * v.f -\/ 1, v.e -\/ 2)  \textcolor{comment}{// (B)}}
\DoxyCodeLine{12874                           : diyfp(2 * v.f -\/ 1, v.e -\/ 1); \textcolor{comment}{// (A)}}
\DoxyCodeLine{12875 }
\DoxyCodeLine{12876     \textcolor{comment}{// Determine the normalized w+ = m+.}}
\DoxyCodeLine{12877     \textcolor{keyword}{const} diyfp w\_plus = diyfp::normalize(m\_plus);}
\DoxyCodeLine{12878 }
\DoxyCodeLine{12879     \textcolor{comment}{// Determine w-\/ = m-\/ such that e\_(w-\/) = e\_(w+).}}
\DoxyCodeLine{12880     \textcolor{keyword}{const} diyfp w\_minus = diyfp::normalize\_to(m\_minus, w\_plus.e);}
\DoxyCodeLine{12881 }
\DoxyCodeLine{12882     \textcolor{keywordflow}{return} \{diyfp::normalize(v), w\_minus, w\_plus\};}
\DoxyCodeLine{12883 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!find\_largest\_pow10@{find\_largest\_pow10}}
\index{find\_largest\_pow10@{find\_largest\_pow10}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{find\_largest\_pow10()}{find\_largest\_pow10()}}
{\footnotesize\ttfamily int nlohmann\+::detail\+::dtoa\+\_\+impl\+::find\+\_\+largest\+\_\+pow10 (\begin{DoxyParamCaption}\item[{const std\+::uint32\+\_\+t}]{n,  }\item[{std\+::uint32\+\_\+t \&}]{pow10 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

For n != 0, returns k, such that pow10 \+:= 10$^\wedge$(k-\/1) $<$= n $<$ 10$^\wedge$k. For n == 0, returns 1 and sets pow10 \+:= 1. 

Definition at line 13121 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13122 \{}
\DoxyCodeLine{13123     \textcolor{comment}{// LCOV\_EXCL\_START}}
\DoxyCodeLine{13124     \textcolor{keywordflow}{if} (n >= 1000000000)}
\DoxyCodeLine{13125     \{}
\DoxyCodeLine{13126         pow10 = 1000000000;}
\DoxyCodeLine{13127         \textcolor{keywordflow}{return} 10;}
\DoxyCodeLine{13128     \}}
\DoxyCodeLine{13129     \textcolor{comment}{// LCOV\_EXCL\_STOP}}
\DoxyCodeLine{13130     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 100000000)}
\DoxyCodeLine{13131     \{}
\DoxyCodeLine{13132         pow10 = 100000000;}
\DoxyCodeLine{13133         \textcolor{keywordflow}{return}  9;}
\DoxyCodeLine{13134     \}}
\DoxyCodeLine{13135     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 10000000)}
\DoxyCodeLine{13136     \{}
\DoxyCodeLine{13137         pow10 = 10000000;}
\DoxyCodeLine{13138         \textcolor{keywordflow}{return}  8;}
\DoxyCodeLine{13139     \}}
\DoxyCodeLine{13140     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 1000000)}
\DoxyCodeLine{13141     \{}
\DoxyCodeLine{13142         pow10 = 1000000;}
\DoxyCodeLine{13143         \textcolor{keywordflow}{return}  7;}
\DoxyCodeLine{13144     \}}
\DoxyCodeLine{13145     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 100000)}
\DoxyCodeLine{13146     \{}
\DoxyCodeLine{13147         pow10 = 100000;}
\DoxyCodeLine{13148         \textcolor{keywordflow}{return}  6;}
\DoxyCodeLine{13149     \}}
\DoxyCodeLine{13150     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 10000)}
\DoxyCodeLine{13151     \{}
\DoxyCodeLine{13152         pow10 = 10000;}
\DoxyCodeLine{13153         \textcolor{keywordflow}{return}  5;}
\DoxyCodeLine{13154     \}}
\DoxyCodeLine{13155     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 1000)}
\DoxyCodeLine{13156     \{}
\DoxyCodeLine{13157         pow10 = 1000;}
\DoxyCodeLine{13158         \textcolor{keywordflow}{return}  4;}
\DoxyCodeLine{13159     \}}
\DoxyCodeLine{13160     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 100)}
\DoxyCodeLine{13161     \{}
\DoxyCodeLine{13162         pow10 = 100;}
\DoxyCodeLine{13163         \textcolor{keywordflow}{return}  3;}
\DoxyCodeLine{13164     \}}
\DoxyCodeLine{13165     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n >= 10)}
\DoxyCodeLine{13166     \{}
\DoxyCodeLine{13167         pow10 = 10;}
\DoxyCodeLine{13168         \textcolor{keywordflow}{return}  2;}
\DoxyCodeLine{13169     \}}
\DoxyCodeLine{13170     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13171     \{}
\DoxyCodeLine{13172         pow10 = 1;}
\DoxyCodeLine{13173         \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13174     \}}
\DoxyCodeLine{13175 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_ab441f2761e33839ca48bc2225e14a2a9}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!format\_buffer@{format\_buffer}}
\index{format\_buffer@{format\_buffer}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{format\_buffer()}{format\_buffer()}}
{\footnotesize\ttfamily J\+S\+O\+N\+\_\+\+H\+E\+D\+L\+E\+Y\+\_\+\+R\+E\+T\+U\+R\+N\+S\+\_\+\+N\+O\+N\+\_\+\+N\+U\+LL char$\ast$ nlohmann\+::detail\+::dtoa\+\_\+impl\+::format\+\_\+buffer (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int}]{len,  }\item[{int}]{decimal\+\_\+exponent,  }\item[{int}]{min\+\_\+exp,  }\item[{int}]{max\+\_\+exp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



prettify v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent 

If v is in the range \mbox{[}10$^\wedge$min\+\_\+exp, 10$^\wedge$max\+\_\+exp) it will be printed in fixed-\/point notation. Otherwise it will be printed in exponential notation.

\begin{DoxyPrecond}{Precondition}
min\+\_\+exp $<$ 0 

max\+\_\+exp $>$ 0 
\end{DoxyPrecond}


Definition at line 13611 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13613 \{}
\DoxyCodeLine{13614     assert(min\_exp < 0);}
\DoxyCodeLine{13615     assert(max\_exp > 0);}
\DoxyCodeLine{13616 }
\DoxyCodeLine{13617     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = len;}
\DoxyCodeLine{13618     \textcolor{keyword}{const} \textcolor{keywordtype}{int} n = len + decimal\_exponent;}
\DoxyCodeLine{13619 }
\DoxyCodeLine{13620     \textcolor{comment}{// v = buf * 10\string^(n-\/k)}}
\DoxyCodeLine{13621     \textcolor{comment}{// k is the length of the buffer (number of decimal digits)}}
\DoxyCodeLine{13622     \textcolor{comment}{// n is the position of the decimal point relative to the start of the buffer.}}
\DoxyCodeLine{13623 }
\DoxyCodeLine{13624     \textcolor{keywordflow}{if} (k <= n and n <= max\_exp)}
\DoxyCodeLine{13625     \{}
\DoxyCodeLine{13626         \textcolor{comment}{// digits[000]}}
\DoxyCodeLine{13627         \textcolor{comment}{// len <= max\_exp + 2}}
\DoxyCodeLine{13628 }
\DoxyCodeLine{13629         std::memset(buf + k, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n -\/ k));}
\DoxyCodeLine{13630         \textcolor{comment}{// Make it look like a floating-\/point number (\#362, \#378)}}
\DoxyCodeLine{13631         buf[n + 0] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13632         buf[n + 1] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{13633         \textcolor{keywordflow}{return} buf + (n + 2);}
\DoxyCodeLine{13634     \}}
\DoxyCodeLine{13635 }
\DoxyCodeLine{13636     \textcolor{keywordflow}{if} (0 < n and n <= max\_exp)}
\DoxyCodeLine{13637     \{}
\DoxyCodeLine{13638         \textcolor{comment}{// dig.its}}
\DoxyCodeLine{13639         \textcolor{comment}{// len <= max\_digits10 + 1}}
\DoxyCodeLine{13640 }
\DoxyCodeLine{13641         assert(k > n);}
\DoxyCodeLine{13642 }
\DoxyCodeLine{13643         std::memmove(buf + (n + 1), buf + n, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k -\/ n));}
\DoxyCodeLine{13644         buf[n] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13645         \textcolor{keywordflow}{return} buf + (k + 1);}
\DoxyCodeLine{13646     \}}
\DoxyCodeLine{13647 }
\DoxyCodeLine{13648     \textcolor{keywordflow}{if} (min\_exp < n and n <= 0)}
\DoxyCodeLine{13649     \{}
\DoxyCodeLine{13650         \textcolor{comment}{// 0.[000]digits}}
\DoxyCodeLine{13651         \textcolor{comment}{// len <= 2 + (-\/min\_exp -\/ 1) + max\_digits10}}
\DoxyCodeLine{13652 }
\DoxyCodeLine{13653         std::memmove(buf + (2 + -\/n), buf, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k));}
\DoxyCodeLine{13654         buf[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{13655         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13656         std::memset(buf + 2, \textcolor{charliteral}{'0'}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(-\/n));}
\DoxyCodeLine{13657         \textcolor{keywordflow}{return} buf + (2 + (-\/n) + k);}
\DoxyCodeLine{13658     \}}
\DoxyCodeLine{13659 }
\DoxyCodeLine{13660     \textcolor{keywordflow}{if} (k == 1)}
\DoxyCodeLine{13661     \{}
\DoxyCodeLine{13662         \textcolor{comment}{// dE+123}}
\DoxyCodeLine{13663         \textcolor{comment}{// len <= 1 + 5}}
\DoxyCodeLine{13664 }
\DoxyCodeLine{13665         buf += 1;}
\DoxyCodeLine{13666     \}}
\DoxyCodeLine{13667     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13668     \{}
\DoxyCodeLine{13669         \textcolor{comment}{// d.igitsE+123}}
\DoxyCodeLine{13670         \textcolor{comment}{// len <= max\_digits10 + 1 + 5}}
\DoxyCodeLine{13671 }
\DoxyCodeLine{13672         std::memmove(buf + 2, buf + 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(k -\/ 1));}
\DoxyCodeLine{13673         buf[1] = \textcolor{charliteral}{'.'};}
\DoxyCodeLine{13674         buf += 1 + k;}
\DoxyCodeLine{13675     \}}
\DoxyCodeLine{13676 }
\DoxyCodeLine{13677     *buf++ = \textcolor{charliteral}{'e'};}
\DoxyCodeLine{13678     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_ad90f19ed10d8133b727df4b9bc5ddf5c}{append\_exponent}}(buf, n -\/ 1);}
\DoxyCodeLine{13679 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!get\_cached\_power\_for\_binary\_exponent@{get\_cached\_power\_for\_binary\_exponent}}
\index{get\_cached\_power\_for\_binary\_exponent@{get\_cached\_power\_for\_binary\_exponent}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{get\_cached\_power\_for\_binary\_exponent()}{get\_cached\_power\_for\_binary\_exponent()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1cached__power}{cached\+\_\+power}} nlohmann\+::detail\+::dtoa\+\_\+impl\+::get\+\_\+cached\+\_\+power\+\_\+for\+\_\+binary\+\_\+exponent (\begin{DoxyParamCaption}\item[{int}]{e }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

For a normalized diyfp w = f $\ast$ 2$^\wedge$e, this function returns a (normalized) cached power-\/of-\/ten c = f\+\_\+c $\ast$ 2$^\wedge$e\+\_\+c, such that the exponent of the product w $\ast$ c satisfies (Definition 3.\+2 from \mbox{[}1\mbox{]}) \begin{DoxyVerb} alpha <= e_c + e + q <= gamma.
\end{DoxyVerb}
 

Definition at line 12957 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{12958 \{}
\DoxyCodeLine{12959     \textcolor{comment}{// Now}}
\DoxyCodeLine{12960     \textcolor{comment}{//}}
\DoxyCodeLine{12961     \textcolor{comment}{//      alpha <= e\_c + e + q <= gamma                                    (1)}}
\DoxyCodeLine{12962     \textcolor{comment}{//      ==> f\_c * 2\string^alpha <= c * 2\string^e * 2\string^q}}
\DoxyCodeLine{12963     \textcolor{comment}{//}}
\DoxyCodeLine{12964     \textcolor{comment}{// and since the c's are normalized, 2\string^(q-\/1) <= f\_c,}}
\DoxyCodeLine{12965     \textcolor{comment}{//}}
\DoxyCodeLine{12966     \textcolor{comment}{//      ==> 2\string^(q -\/ 1 + alpha) <= c * 2\string^(e + q)}}
\DoxyCodeLine{12967     \textcolor{comment}{//      ==> 2\string^(alpha -\/ e -\/ 1) <= c}}
\DoxyCodeLine{12968     \textcolor{comment}{//}}
\DoxyCodeLine{12969     \textcolor{comment}{// If c were an exact power of ten, i.e. c = 10\string^k, one may determine k as}}
\DoxyCodeLine{12970     \textcolor{comment}{//}}
\DoxyCodeLine{12971     \textcolor{comment}{//      k = ceil( log\_10( 2\string^(alpha -\/ e -\/ 1) ) )}}
\DoxyCodeLine{12972     \textcolor{comment}{//        = ceil( (alpha -\/ e -\/ 1) * log\_10(2) )}}
\DoxyCodeLine{12973     \textcolor{comment}{//}}
\DoxyCodeLine{12974     \textcolor{comment}{// From the paper:}}
\DoxyCodeLine{12975     \textcolor{comment}{// "In theory the result of the procedure could be wrong since c is rounded,}}
\DoxyCodeLine{12976     \textcolor{comment}{//  and the computation itself is approximated [...]. In practice, however,}}
\DoxyCodeLine{12977     \textcolor{comment}{//  this simple function is sufficient."}}
\DoxyCodeLine{12978     \textcolor{comment}{//}}
\DoxyCodeLine{12979     \textcolor{comment}{// For IEEE double precision floating-\/point numbers converted into}}
\DoxyCodeLine{12980     \textcolor{comment}{// normalized diyfp's w = f * 2\string^e, with q = 64,}}
\DoxyCodeLine{12981     \textcolor{comment}{//}}
\DoxyCodeLine{12982     \textcolor{comment}{//      e >= -\/1022      (min IEEE exponent)}}
\DoxyCodeLine{12983     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{12984     \textcolor{comment}{//           -\/52        (p -\/ 1, possibly normalize denormal IEEE numbers)}}
\DoxyCodeLine{12985     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{12986     \textcolor{comment}{//         = -\/1137}}
\DoxyCodeLine{12987     \textcolor{comment}{//}}
\DoxyCodeLine{12988     \textcolor{comment}{// and}}
\DoxyCodeLine{12989     \textcolor{comment}{//}}
\DoxyCodeLine{12990     \textcolor{comment}{//      e <= +1023      (max IEEE exponent)}}
\DoxyCodeLine{12991     \textcolor{comment}{//           -\/52        (p -\/ 1)}}
\DoxyCodeLine{12992     \textcolor{comment}{//           -\/11        (normalize the diyfp)}}
\DoxyCodeLine{12993     \textcolor{comment}{//         = 960}}
\DoxyCodeLine{12994     \textcolor{comment}{//}}
\DoxyCodeLine{12995     \textcolor{comment}{// This binary exponent range [-\/1137,960] results in a decimal exponent}}
\DoxyCodeLine{12996     \textcolor{comment}{// range [-\/307,324]. One does not need to store a cached power for each}}
\DoxyCodeLine{12997     \textcolor{comment}{// k in this range. For each such k it suffices to find a cached power}}
\DoxyCodeLine{12998     \textcolor{comment}{// such that the exponent of the product lies in [alpha,gamma].}}
\DoxyCodeLine{12999     \textcolor{comment}{// This implies that the difference of the decimal exponents of adjacent}}
\DoxyCodeLine{13000     \textcolor{comment}{// table entries must be less than or equal to}}
\DoxyCodeLine{13001     \textcolor{comment}{//}}
\DoxyCodeLine{13002     \textcolor{comment}{//      floor( (gamma -\/ alpha) * log\_10(2) ) = 8.}}
\DoxyCodeLine{13003     \textcolor{comment}{//}}
\DoxyCodeLine{13004     \textcolor{comment}{// (A smaller distance gamma-\/alpha would require a larger table.)}}
\DoxyCodeLine{13005 }
\DoxyCodeLine{13006     \textcolor{comment}{// NB:}}
\DoxyCodeLine{13007     \textcolor{comment}{// Actually this function returns c, such that -\/60 <= e\_c + e + 64 <= -\/34.}}
\DoxyCodeLine{13008 }
\DoxyCodeLine{13009     constexpr \textcolor{keywordtype}{int} kCachedPowersMinDecExp = -\/300;}
\DoxyCodeLine{13010     constexpr \textcolor{keywordtype}{int} kCachedPowersDecStep = 8;}
\DoxyCodeLine{13011 }
\DoxyCodeLine{13012     \textcolor{keyword}{static} constexpr std::array<cached\_power, 79> kCachedPowers =}
\DoxyCodeLine{13013     \{}
\DoxyCodeLine{13014         \{}
\DoxyCodeLine{13015             \{ 0xAB70FE17C79AC6CA, -\/1060, -\/300 \},}
\DoxyCodeLine{13016             \{ 0xFF77B1FCBEBCDC4F, -\/1034, -\/292 \},}
\DoxyCodeLine{13017             \{ 0xBE5691EF416BD60C, -\/1007, -\/284 \},}
\DoxyCodeLine{13018             \{ 0x8DD01FAD907FFC3C,  -\/980, -\/276 \},}
\DoxyCodeLine{13019             \{ 0xD3515C2831559A83,  -\/954, -\/268 \},}
\DoxyCodeLine{13020             \{ 0x9D71AC8FADA6C9B5,  -\/927, -\/260 \},}
\DoxyCodeLine{13021             \{ 0xEA9C227723EE8BCB,  -\/901, -\/252 \},}
\DoxyCodeLine{13022             \{ 0xAECC49914078536D,  -\/874, -\/244 \},}
\DoxyCodeLine{13023             \{ 0x823C12795DB6CE57,  -\/847, -\/236 \},}
\DoxyCodeLine{13024             \{ 0xC21094364DFB5637,  -\/821, -\/228 \},}
\DoxyCodeLine{13025             \{ 0x9096EA6F3848984F,  -\/794, -\/220 \},}
\DoxyCodeLine{13026             \{ 0xD77485CB25823AC7,  -\/768, -\/212 \},}
\DoxyCodeLine{13027             \{ 0xA086CFCD97BF97F4,  -\/741, -\/204 \},}
\DoxyCodeLine{13028             \{ 0xEF340A98172AACE5,  -\/715, -\/196 \},}
\DoxyCodeLine{13029             \{ 0xB23867FB2A35B28E,  -\/688, -\/188 \},}
\DoxyCodeLine{13030             \{ 0x84C8D4DFD2C63F3B,  -\/661, -\/180 \},}
\DoxyCodeLine{13031             \{ 0xC5DD44271AD3CDBA,  -\/635, -\/172 \},}
\DoxyCodeLine{13032             \{ 0x936B9FCEBB25C996,  -\/608, -\/164 \},}
\DoxyCodeLine{13033             \{ 0xDBAC6C247D62A584,  -\/582, -\/156 \},}
\DoxyCodeLine{13034             \{ 0xA3AB66580D5FDAF6,  -\/555, -\/148 \},}
\DoxyCodeLine{13035             \{ 0xF3E2F893DEC3F126,  -\/529, -\/140 \},}
\DoxyCodeLine{13036             \{ 0xB5B5ADA8AAFF80B8,  -\/502, -\/132 \},}
\DoxyCodeLine{13037             \{ 0x87625F056C7C4A8B,  -\/475, -\/124 \},}
\DoxyCodeLine{13038             \{ 0xC9BCFF6034C13053,  -\/449, -\/116 \},}
\DoxyCodeLine{13039             \{ 0x964E858C91BA2655,  -\/422, -\/108 \},}
\DoxyCodeLine{13040             \{ 0xDFF9772470297EBD,  -\/396, -\/100 \},}
\DoxyCodeLine{13041             \{ 0xA6DFBD9FB8E5B88F,  -\/369,  -\/92 \},}
\DoxyCodeLine{13042             \{ 0xF8A95FCF88747D94,  -\/343,  -\/84 \},}
\DoxyCodeLine{13043             \{ 0xB94470938FA89BCF,  -\/316,  -\/76 \},}
\DoxyCodeLine{13044             \{ 0x8A08F0F8BF0F156B,  -\/289,  -\/68 \},}
\DoxyCodeLine{13045             \{ 0xCDB02555653131B6,  -\/263,  -\/60 \},}
\DoxyCodeLine{13046             \{ 0x993FE2C6D07B7FAC,  -\/236,  -\/52 \},}
\DoxyCodeLine{13047             \{ 0xE45C10C42A2B3B06,  -\/210,  -\/44 \},}
\DoxyCodeLine{13048             \{ 0xAA242499697392D3,  -\/183,  -\/36 \},}
\DoxyCodeLine{13049             \{ 0xFD87B5F28300CA0E,  -\/157,  -\/28 \},}
\DoxyCodeLine{13050             \{ 0xBCE5086492111AEB,  -\/130,  -\/20 \},}
\DoxyCodeLine{13051             \{ 0x8CBCCC096F5088CC,  -\/103,  -\/12 \},}
\DoxyCodeLine{13052             \{ 0xD1B71758E219652C,   -\/77,   -\/4 \},}
\DoxyCodeLine{13053             \{ 0x9C40000000000000,   -\/50,    4 \},}
\DoxyCodeLine{13054             \{ 0xE8D4A51000000000,   -\/24,   12 \},}
\DoxyCodeLine{13055             \{ 0xAD78EBC5AC620000,     3,   20 \},}
\DoxyCodeLine{13056             \{ 0x813F3978F8940984,    30,   28 \},}
\DoxyCodeLine{13057             \{ 0xC097CE7BC90715B3,    56,   36 \},}
\DoxyCodeLine{13058             \{ 0x8F7E32CE7BEA5C70,    83,   44 \},}
\DoxyCodeLine{13059             \{ 0xD5D238A4ABE98068,   109,   52 \},}
\DoxyCodeLine{13060             \{ 0x9F4F2726179A2245,   136,   60 \},}
\DoxyCodeLine{13061             \{ 0xED63A231D4C4FB27,   162,   68 \},}
\DoxyCodeLine{13062             \{ 0xB0DE65388CC8ADA8,   189,   76 \},}
\DoxyCodeLine{13063             \{ 0x83C7088E1AAB65DB,   216,   84 \},}
\DoxyCodeLine{13064             \{ 0xC45D1DF942711D9A,   242,   92 \},}
\DoxyCodeLine{13065             \{ 0x924D692CA61BE758,   269,  100 \},}
\DoxyCodeLine{13066             \{ 0xDA01EE641A708DEA,   295,  108 \},}
\DoxyCodeLine{13067             \{ 0xA26DA3999AEF774A,   322,  116 \},}
\DoxyCodeLine{13068             \{ 0xF209787BB47D6B85,   348,  124 \},}
\DoxyCodeLine{13069             \{ 0xB454E4A179DD1877,   375,  132 \},}
\DoxyCodeLine{13070             \{ 0x865B86925B9BC5C2,   402,  140 \},}
\DoxyCodeLine{13071             \{ 0xC83553C5C8965D3D,   428,  148 \},}
\DoxyCodeLine{13072             \{ 0x952AB45CFA97A0B3,   455,  156 \},}
\DoxyCodeLine{13073             \{ 0xDE469FBD99A05FE3,   481,  164 \},}
\DoxyCodeLine{13074             \{ 0xA59BC234DB398C25,   508,  172 \},}
\DoxyCodeLine{13075             \{ 0xF6C69A72A3989F5C,   534,  180 \},}
\DoxyCodeLine{13076             \{ 0xB7DCBF5354E9BECE,   561,  188 \},}
\DoxyCodeLine{13077             \{ 0x88FCF317F22241E2,   588,  196 \},}
\DoxyCodeLine{13078             \{ 0xCC20CE9BD35C78A5,   614,  204 \},}
\DoxyCodeLine{13079             \{ 0x98165AF37B2153DF,   641,  212 \},}
\DoxyCodeLine{13080             \{ 0xE2A0B5DC971F303A,   667,  220 \},}
\DoxyCodeLine{13081             \{ 0xA8D9D1535CE3B396,   694,  228 \},}
\DoxyCodeLine{13082             \{ 0xFB9B7CD9A4A7443C,   720,  236 \},}
\DoxyCodeLine{13083             \{ 0xBB764C4CA7A44410,   747,  244 \},}
\DoxyCodeLine{13084             \{ 0x8BAB8EEFB6409C1A,   774,  252 \},}
\DoxyCodeLine{13085             \{ 0xD01FEF10A657842C,   800,  260 \},}
\DoxyCodeLine{13086             \{ 0x9B10A4E5E9913129,   827,  268 \},}
\DoxyCodeLine{13087             \{ 0xE7109BFBA19C0C9D,   853,  276 \},}
\DoxyCodeLine{13088             \{ 0xAC2820D9623BF429,   880,  284 \},}
\DoxyCodeLine{13089             \{ 0x80444B5E7AA7CF85,   907,  292 \},}
\DoxyCodeLine{13090             \{ 0xBF21E44003ACDD2D,   933,  300 \},}
\DoxyCodeLine{13091             \{ 0x8E679C2F5E44FF8F,   960,  308 \},}
\DoxyCodeLine{13092             \{ 0xD433179D9C8CB841,   986,  316 \},}
\DoxyCodeLine{13093             \{ 0x9E19DB92B4E31BA9,  1013,  324 \},}
\DoxyCodeLine{13094         \}}
\DoxyCodeLine{13095     \};}
\DoxyCodeLine{13096 }
\DoxyCodeLine{13097     \textcolor{comment}{// This computation gives exactly the same results for k as}}
\DoxyCodeLine{13098     \textcolor{comment}{//      k = ceil((kAlpha -\/ e -\/ 1) * 0.30102999566398114)}}
\DoxyCodeLine{13099     \textcolor{comment}{// for |e| <= 1500, but doesn't require floating-\/point operations.}}
\DoxyCodeLine{13100     \textcolor{comment}{// NB: log\_10(2) \string~= 78913 / 2\string^18}}
\DoxyCodeLine{13101     assert(e >= -\/1500);}
\DoxyCodeLine{13102     assert(e <=  1500);}
\DoxyCodeLine{13103     \textcolor{keyword}{const} \textcolor{keywordtype}{int} f = kAlpha -\/ e -\/ 1;}
\DoxyCodeLine{13104     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = (f * 78913) / (1 << 18) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(f > 0);}
\DoxyCodeLine{13105 }
\DoxyCodeLine{13106     \textcolor{keyword}{const} \textcolor{keywordtype}{int} index = (-\/kCachedPowersMinDecExp + k + (kCachedPowersDecStep -\/ 1)) / kCachedPowersDecStep;}
\DoxyCodeLine{13107     assert(index >= 0);}
\DoxyCodeLine{13108     assert(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index) < kCachedPowers.size());}
\DoxyCodeLine{13109 }
\DoxyCodeLine{13110     \textcolor{keyword}{const} cached\_power cached = kCachedPowers[\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(index)];}
\DoxyCodeLine{13111     assert(kAlpha <= cached.e + e + 64);}
\DoxyCodeLine{13112     assert(kGamma >= cached.e + e + 64);}
\DoxyCodeLine{13113 }
\DoxyCodeLine{13114     \textcolor{keywordflow}{return} cached;}
\DoxyCodeLine{13115 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!grisu2@{grisu2}}
\index{grisu2@{grisu2}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{grisu2()}{grisu2()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void nlohmann\+::detail\+::dtoa\+\_\+impl\+::grisu2 (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int \&}]{len,  }\item[{int \&}]{decimal\+\_\+exponent,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{m\+\_\+minus,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{v,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{m\+\_\+plus }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent len is the length of the buffer (number of decimal digits) The buffer must be large enough, i.\+e. $>$= max\+\_\+digits10. 

Definition at line 13459 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13461 \{}
\DoxyCodeLine{13462     assert(m\_plus.e == m\_minus.e);}
\DoxyCodeLine{13463     assert(m\_plus.e == v.e);}
\DoxyCodeLine{13464 }
\DoxyCodeLine{13465     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (A)}}
\DoxyCodeLine{13466     \textcolor{comment}{//          m-\/                      v                       m+}}
\DoxyCodeLine{13467     \textcolor{comment}{//}}
\DoxyCodeLine{13468     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/    (B)}}
\DoxyCodeLine{13469     \textcolor{comment}{//                      m-\/          v                       m+}}
\DoxyCodeLine{13470     \textcolor{comment}{//}}
\DoxyCodeLine{13471     \textcolor{comment}{// First scale v (and m-\/ and m+) such that the exponent is in the range}}
\DoxyCodeLine{13472     \textcolor{comment}{// [alpha, gamma].}}
\DoxyCodeLine{13473 }
\DoxyCodeLine{13474     \textcolor{keyword}{const} cached\_power cached = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_adbf329a18c5cf854a3477327afd2200b}{get\_cached\_power\_for\_binary\_exponent}}(m\_plus.e);}
\DoxyCodeLine{13475 }
\DoxyCodeLine{13476     \textcolor{keyword}{const} diyfp c\_minus\_k(cached.f, cached.e); \textcolor{comment}{// = c \string~= 10\string^-\/k}}
\DoxyCodeLine{13477 }
\DoxyCodeLine{13478     \textcolor{comment}{// The exponent of the products is = v.e + c\_minus\_k.e + q and is in the range [alpha,gamma]}}
\DoxyCodeLine{13479     \textcolor{keyword}{const} diyfp w       = diyfp::mul(v,       c\_minus\_k);}
\DoxyCodeLine{13480     \textcolor{keyword}{const} diyfp w\_minus = diyfp::mul(m\_minus, c\_minus\_k);}
\DoxyCodeLine{13481     \textcolor{keyword}{const} diyfp w\_plus  = diyfp::mul(m\_plus,  c\_minus\_k);}
\DoxyCodeLine{13482 }
\DoxyCodeLine{13483     \textcolor{comment}{//  -\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/}}
\DoxyCodeLine{13484     \textcolor{comment}{//          w-\/                      w                       w+}}
\DoxyCodeLine{13485     \textcolor{comment}{//          = c*m-\/                  = c*v                   = c*m+}}
\DoxyCodeLine{13486     \textcolor{comment}{//}}
\DoxyCodeLine{13487     \textcolor{comment}{// diyfp::mul rounds its result and c\_minus\_k is approximated too. w, w-\/ and}}
\DoxyCodeLine{13488     \textcolor{comment}{// w+ are now off by a small amount.}}
\DoxyCodeLine{13489     \textcolor{comment}{// In fact:}}
\DoxyCodeLine{13490     \textcolor{comment}{//}}
\DoxyCodeLine{13491     \textcolor{comment}{//      w -\/ v * 10\string^k < 1 ulp}}
\DoxyCodeLine{13492     \textcolor{comment}{//}}
\DoxyCodeLine{13493     \textcolor{comment}{// To account for this inaccuracy, add resp. subtract 1 ulp.}}
\DoxyCodeLine{13494     \textcolor{comment}{//}}
\DoxyCodeLine{13495     \textcolor{comment}{//  -\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/(-\/-\/-\/+-\/-\/-\/)-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{13496     \textcolor{comment}{//          w-\/  M-\/                  w                   M+  w+}}
\DoxyCodeLine{13497     \textcolor{comment}{//}}
\DoxyCodeLine{13498     \textcolor{comment}{// Now any number in [M-\/, M+] (bounds included) will round to w when input,}}
\DoxyCodeLine{13499     \textcolor{comment}{// regardless of how the input rounding algorithm breaks ties.}}
\DoxyCodeLine{13500     \textcolor{comment}{//}}
\DoxyCodeLine{13501     \textcolor{comment}{// And digit\_gen generates the shortest possible such number in [M-\/, M+].}}
\DoxyCodeLine{13502     \textcolor{comment}{// Note that this does not mean that Grisu2 always generates the shortest}}
\DoxyCodeLine{13503     \textcolor{comment}{// possible number in the interval (m-\/, m+).}}
\DoxyCodeLine{13504     \textcolor{keyword}{const} diyfp M\_minus(w\_minus.f + 1, w\_minus.e);}
\DoxyCodeLine{13505     \textcolor{keyword}{const} diyfp M\_plus (w\_plus.f  -\/ 1, w\_plus.e );}
\DoxyCodeLine{13506 }
\DoxyCodeLine{13507     decimal\_exponent = -\/cached.k; \textcolor{comment}{// = -\/(-\/k) = k}}
\DoxyCodeLine{13508 }
\DoxyCodeLine{13509     \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}{grisu2\_digit\_gen}}(buf, len, decimal\_exponent, M\_minus, w, M\_plus);}
\DoxyCodeLine{13510 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_aab7a9670a4f4704a5d0347ad7588576b}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!grisu2@{grisu2}}
\index{grisu2@{grisu2}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{grisu2()}{grisu2()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Float\+Type $>$ \\
void nlohmann\+::detail\+::dtoa\+\_\+impl\+::grisu2 (\begin{DoxyParamCaption}\item[{char $\ast$}]{buf,  }\item[{int \&}]{len,  }\item[{int \&}]{decimal\+\_\+exponent,  }\item[{Float\+Type}]{value }\end{DoxyParamCaption})}

v = buf $\ast$ 10$^\wedge$decimal\+\_\+exponent len is the length of the buffer (number of decimal digits) The buffer must be large enough, i.\+e. $>$= max\+\_\+digits10. 

Definition at line 13519 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13520 \{}
\DoxyCodeLine{13521     static\_assert(diyfp::kPrecision >= std::numeric\_limits<FloatType>::digits + 3,}
\DoxyCodeLine{13522                   \textcolor{stringliteral}{"internal error: not enough precision"});}
\DoxyCodeLine{13523 }
\DoxyCodeLine{13524     assert(std::isfinite(value));}
\DoxyCodeLine{13525     assert(value > 0);}
\DoxyCodeLine{13526 }
\DoxyCodeLine{13527     \textcolor{comment}{// If the neighbors (and boundaries) of 'value' are always computed for double-\/precision}}
\DoxyCodeLine{13528     \textcolor{comment}{// numbers, all float's can be recovered using strtod (and strtof). However, the resulting}}
\DoxyCodeLine{13529     \textcolor{comment}{// decimal representations are not exactly "short".}}
\DoxyCodeLine{13530     \textcolor{comment}{//}}
\DoxyCodeLine{13531     \textcolor{comment}{// The documentation for 'std::to\_chars' (https://en.cppreference.com/w/cpp/utility/to\_chars)}}
\DoxyCodeLine{13532     \textcolor{comment}{// says "value is converted to a string as if by std::sprintf in the default ("C") locale"}}
\DoxyCodeLine{13533     \textcolor{comment}{// and since sprintf promotes float's to double's, I think this is exactly what 'std::to\_chars'}}
\DoxyCodeLine{13534     \textcolor{comment}{// does.}}
\DoxyCodeLine{13535     \textcolor{comment}{// On the other hand, the documentation for 'std::to\_chars' requires that "parsing the}}
\DoxyCodeLine{13536     \textcolor{comment}{// representation using the corresponding std::from\_chars function recovers value exactly". That}}
\DoxyCodeLine{13537     \textcolor{comment}{// indicates that single precision floating-\/point numbers should be recovered using}}
\DoxyCodeLine{13538     \textcolor{comment}{// 'std::strtof'.}}
\DoxyCodeLine{13539     \textcolor{comment}{//}}
\DoxyCodeLine{13540     \textcolor{comment}{// NB: If the neighbors are computed for single-\/precision numbers, there is a single float}}
\DoxyCodeLine{13541     \textcolor{comment}{//     (7.0385307e-\/26f) which can't be recovered using strtod. The resulting double precision}}
\DoxyCodeLine{13542     \textcolor{comment}{//     value is off by 1 ulp.}}
\DoxyCodeLine{13543 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{13544     \textcolor{keyword}{const} boundaries w = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}{compute\_boundaries}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{13545 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{13546     \textcolor{keyword}{const} boundaries w = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a22b6e37654ac93c6d0d9c06ec1bf5ded}{compute\_boundaries}}(value);}
\DoxyCodeLine{13547 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13548 }
\DoxyCodeLine{13549     \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a05b681dcb8569b9784c6dccfadb01633}{grisu2}}(buf, len, decimal\_exponent, w.minus, w.w, w.plus);}
\DoxyCodeLine{13550 \}}

\end{DoxyCode}
\mbox{\Hypertarget{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}\label{namespacenlohmann_1_1detail_1_1dtoa__impl_a9b899c72b0e1e3dd46d75c2b4e6bcdfb}} 
\index{nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}!grisu2\_digit\_gen@{grisu2\_digit\_gen}}
\index{grisu2\_digit\_gen@{grisu2\_digit\_gen}!nlohmann::detail::dtoa\_impl@{nlohmann::detail::dtoa\_impl}}
\doxysubsubsection{\texorpdfstring{grisu2\_digit\_gen()}{grisu2\_digit\_gen()}}
{\footnotesize\ttfamily void nlohmann\+::detail\+::dtoa\+\_\+impl\+::grisu2\+\_\+digit\+\_\+gen (\begin{DoxyParamCaption}\item[{char $\ast$}]{buffer,  }\item[{int \&}]{length,  }\item[{int \&}]{decimal\+\_\+exponent,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{M\+\_\+minus,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{w,  }\item[{\mbox{\hyperlink{structnlohmann_1_1detail_1_1dtoa__impl_1_1diyfp}{diyfp}}}]{M\+\_\+plus }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Generates V = buffer $\ast$ 10$^\wedge$decimal\+\_\+exponent, such that M-\/ $<$= V $<$= M+. M-\/ and M+ must be normalized and share the same exponent -\/60 $<$= e $<$= -\/32. 

Definition at line 13218 of file json.\+hpp.


\begin{DoxyCode}{0}
\DoxyCodeLine{13220 \{}
\DoxyCodeLine{13221     static\_assert(kAlpha >= -\/60, \textcolor{stringliteral}{"internal error"});}
\DoxyCodeLine{13222     static\_assert(kGamma <= -\/32, \textcolor{stringliteral}{"internal error"});}
\DoxyCodeLine{13223 }
\DoxyCodeLine{13224     \textcolor{comment}{// Generates the digits (and the exponent) of a decimal floating-\/point}}
\DoxyCodeLine{13225     \textcolor{comment}{// number V = buffer * 10\string^decimal\_exponent in the range [M-\/, M+]. The diyfp's}}
\DoxyCodeLine{13226     \textcolor{comment}{// w, M-\/ and M+ share the same exponent e, which satisfies alpha <= e <= gamma.}}
\DoxyCodeLine{13227     \textcolor{comment}{//}}
\DoxyCodeLine{13228     \textcolor{comment}{//               <-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ delta -\/-\/-\/-\/>}}
\DoxyCodeLine{13229     \textcolor{comment}{//                                  <-\/-\/-\/-\/ dist -\/-\/-\/-\/-\/-\/-\/-\/-\/>}}
\DoxyCodeLine{13230     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/[-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/+-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/]-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{13231     \textcolor{comment}{//               M-\/                 w                   M+}}
\DoxyCodeLine{13232     \textcolor{comment}{//}}
\DoxyCodeLine{13233     \textcolor{comment}{// Grisu2 generates the digits of M+ from left to right and stops as soon as}}
\DoxyCodeLine{13234     \textcolor{comment}{// V is in [M-\/,M+].}}
\DoxyCodeLine{13235 }
\DoxyCodeLine{13236     assert(M\_plus.e >= kAlpha);}
\DoxyCodeLine{13237     assert(M\_plus.e <= kGamma);}
\DoxyCodeLine{13238 }
\DoxyCodeLine{13239     std::uint64\_t delta = diyfp::sub(M\_plus, M\_minus).f; \textcolor{comment}{// (significand of (M+ -\/ M-\/), implicit exponent is e)}}
\DoxyCodeLine{13240     std::uint64\_t dist  = diyfp::sub(M\_plus, w      ).f; \textcolor{comment}{// (significand of (M+ -\/ w ), implicit exponent is e)}}
\DoxyCodeLine{13241 }
\DoxyCodeLine{13242     \textcolor{comment}{// Split M+ = f * 2\string^e into two parts p1 and p2 (note: e < 0):}}
\DoxyCodeLine{13243     \textcolor{comment}{//}}
\DoxyCodeLine{13244     \textcolor{comment}{//      M+ = f * 2\string^e}}
\DoxyCodeLine{13245     \textcolor{comment}{//         = ((f div 2\string^-\/e) * 2\string^-\/e + (f mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{13246     \textcolor{comment}{//         = ((p1        ) * 2\string^-\/e + (p2        )) * 2\string^e}}
\DoxyCodeLine{13247     \textcolor{comment}{//         = p1 + p2 * 2\string^e}}
\DoxyCodeLine{13248 }
\DoxyCodeLine{13249     \textcolor{keyword}{const} diyfp one(std::uint64\_t\{1\} << -\/M\_plus.e, M\_plus.e);}
\DoxyCodeLine{13250 }
\DoxyCodeLine{13251     \textcolor{keyword}{auto} p1 = \textcolor{keyword}{static\_cast<}std::uint32\_t\textcolor{keyword}{>}(M\_plus.f >> -\/one.e); \textcolor{comment}{// p1 = f div 2\string^-\/e (Since -\/e >= 32, p1 fits into a 32-\/bit int.)}}
\DoxyCodeLine{13252     std::uint64\_t p2 = M\_plus.f \& (one.f -\/ 1);                    \textcolor{comment}{// p2 = f mod 2\string^-\/e}}
\DoxyCodeLine{13253 }
\DoxyCodeLine{13254     \textcolor{comment}{// 1)}}
\DoxyCodeLine{13255     \textcolor{comment}{//}}
\DoxyCodeLine{13256     \textcolor{comment}{// Generate the digits of the integral part p1 = d[n-\/1]...d[1]d[0]}}
\DoxyCodeLine{13257 }
\DoxyCodeLine{13258     assert(p1 > 0);}
\DoxyCodeLine{13259 }
\DoxyCodeLine{13260     std::uint32\_t pow10;}
\DoxyCodeLine{13261     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = \mbox{\hyperlink{namespacenlohmann_1_1detail_1_1dtoa__impl_a36ded358763b5dbcea9867660fbe4e28}{find\_largest\_pow10}}(p1, pow10);}
\DoxyCodeLine{13262 }
\DoxyCodeLine{13263     \textcolor{comment}{//      10\string^(k-\/1) <= p1 < 10\string^k, pow10 = 10\string^(k-\/1)}}
\DoxyCodeLine{13264     \textcolor{comment}{//}}
\DoxyCodeLine{13265     \textcolor{comment}{//      p1 = (p1 div 10\string^(k-\/1)) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{13266     \textcolor{comment}{//         = (d[k-\/1]         ) * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))}}
\DoxyCodeLine{13267     \textcolor{comment}{//}}
\DoxyCodeLine{13268     \textcolor{comment}{//      M+ = p1                                             + p2 * 2\string^e}}
\DoxyCodeLine{13269     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (p1 mod 10\string^(k-\/1))          + p2 * 2\string^e}}
\DoxyCodeLine{13270     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + ((p1 mod 10\string^(k-\/1)) * 2\string^-\/e + p2) * 2\string^e}}
\DoxyCodeLine{13271     \textcolor{comment}{//         = d[k-\/1] * 10\string^(k-\/1) + (                         rest) * 2\string^e}}
\DoxyCodeLine{13272     \textcolor{comment}{//}}
\DoxyCodeLine{13273     \textcolor{comment}{// Now generate the digits d[n] of p1 from left to right (n = k-\/1,...,0)}}
\DoxyCodeLine{13274     \textcolor{comment}{//}}
\DoxyCodeLine{13275     \textcolor{comment}{//      p1 = d[k-\/1]...d[n] * 10\string^n + d[n-\/1]...d[0]}}
\DoxyCodeLine{13276     \textcolor{comment}{//}}
\DoxyCodeLine{13277     \textcolor{comment}{// but stop as soon as}}
\DoxyCodeLine{13278     \textcolor{comment}{//}}
\DoxyCodeLine{13279     \textcolor{comment}{//      rest * 2\string^e = (d[n-\/1]...d[0] * 2\string^-\/e + p2) * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{13280 }
\DoxyCodeLine{13281     \textcolor{keywordtype}{int} n = k;}
\DoxyCodeLine{13282     \textcolor{keywordflow}{while} (n > 0)}
\DoxyCodeLine{13283     \{}
\DoxyCodeLine{13284         \textcolor{comment}{// Invariants:}}
\DoxyCodeLine{13285         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)    (buffer = 0 for n = k)}}
\DoxyCodeLine{13286         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{13287         \textcolor{comment}{//}}
\DoxyCodeLine{13288         \textcolor{keyword}{const} std::uint32\_t d = p1 / pow10;  \textcolor{comment}{// d = p1 div 10\string^(n-\/1)}}
\DoxyCodeLine{13289         \textcolor{keyword}{const} std::uint32\_t r = p1 \% pow10;  \textcolor{comment}{// r = p1 mod 10\string^(n-\/1)}}
\DoxyCodeLine{13290         \textcolor{comment}{//}}
\DoxyCodeLine{13291         \textcolor{comment}{//      M+ = buffer * 10\string^n + (d * 10\string^(n-\/1) + r) + p2 * 2\string^e}}
\DoxyCodeLine{13292         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{13293         \textcolor{comment}{//}}
\DoxyCodeLine{13294         assert(d <= 9);}
\DoxyCodeLine{13295         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{13296         \textcolor{comment}{//}}
\DoxyCodeLine{13297         \textcolor{comment}{//      M+ = buffer * 10\string^(n-\/1) + (r + p2 * 2\string^e)}}
\DoxyCodeLine{13298         \textcolor{comment}{//}}
\DoxyCodeLine{13299         p1 = r;}
\DoxyCodeLine{13300         n-\/-\/;}
\DoxyCodeLine{13301         \textcolor{comment}{//}}
\DoxyCodeLine{13302         \textcolor{comment}{//      M+ = buffer * 10\string^n + (p1 + p2 * 2\string^e)}}
\DoxyCodeLine{13303         \textcolor{comment}{//      pow10 = 10\string^n}}
\DoxyCodeLine{13304         \textcolor{comment}{//}}
\DoxyCodeLine{13305 }
\DoxyCodeLine{13306         \textcolor{comment}{// Now check if enough digits have been generated.}}
\DoxyCodeLine{13307         \textcolor{comment}{// Compute}}
\DoxyCodeLine{13308         \textcolor{comment}{//}}
\DoxyCodeLine{13309         \textcolor{comment}{//      p1 + p2 * 2\string^e = (p1 * 2\string^-\/e + p2) * 2\string^e = rest * 2\string^e}}
\DoxyCodeLine{13310         \textcolor{comment}{//}}
\DoxyCodeLine{13311         \textcolor{comment}{// Note:}}
\DoxyCodeLine{13312         \textcolor{comment}{// Since rest and delta share the same exponent e, it suffices to}}
\DoxyCodeLine{13313         \textcolor{comment}{// compare the significands.}}
\DoxyCodeLine{13314         \textcolor{keyword}{const} std::uint64\_t rest = (std::uint64\_t\{p1\} << -\/one.e) + p2;}
\DoxyCodeLine{13315         \textcolor{keywordflow}{if} (rest <= delta)}
\DoxyCodeLine{13316         \{}
\DoxyCodeLine{13317             \textcolor{comment}{// V = buffer * 10\string^n, with M-\/ <= V <= M+.}}
\DoxyCodeLine{13318 }
\DoxyCodeLine{13319             decimal\_exponent += n;}
\DoxyCodeLine{13320 }
\DoxyCodeLine{13321             \textcolor{comment}{// We may now just stop. But instead look if the buffer could be}}
\DoxyCodeLine{13322             \textcolor{comment}{// decremented to bring V closer to w.}}
\DoxyCodeLine{13323             \textcolor{comment}{//}}
\DoxyCodeLine{13324             \textcolor{comment}{// pow10 = 10\string^n is now 1 ulp in the decimal representation V.}}
\DoxyCodeLine{13325             \textcolor{comment}{// The rounding procedure works with diyfp's with an implicit}}
\DoxyCodeLine{13326             \textcolor{comment}{// exponent of e.}}
\DoxyCodeLine{13327             \textcolor{comment}{//}}
\DoxyCodeLine{13328             \textcolor{comment}{//      10\string^n = (10\string^n * 2\string^-\/e) * 2\string^e = ulp * 2\string^e}}
\DoxyCodeLine{13329             \textcolor{comment}{//}}
\DoxyCodeLine{13330             \textcolor{keyword}{const} std::uint64\_t ten\_n = std::uint64\_t\{pow10\} << -\/one.e;}
\DoxyCodeLine{13331             grisu2\_round(buffer, length, dist, delta, rest, ten\_n);}
\DoxyCodeLine{13332 }
\DoxyCodeLine{13333             \textcolor{keywordflow}{return};}
\DoxyCodeLine{13334         \}}
\DoxyCodeLine{13335 }
\DoxyCodeLine{13336         pow10 /= 10;}
\DoxyCodeLine{13337         \textcolor{comment}{//}}
\DoxyCodeLine{13338         \textcolor{comment}{//      pow10 = 10\string^(n-\/1) <= p1 < 10\string^n}}
\DoxyCodeLine{13339         \textcolor{comment}{// Invariants restored.}}
\DoxyCodeLine{13340     \}}
\DoxyCodeLine{13341 }
\DoxyCodeLine{13342     \textcolor{comment}{// 2)}}
\DoxyCodeLine{13343     \textcolor{comment}{//}}
\DoxyCodeLine{13344     \textcolor{comment}{// The digits of the integral part have been generated:}}
\DoxyCodeLine{13345     \textcolor{comment}{//}}
\DoxyCodeLine{13346     \textcolor{comment}{//      M+ = d[k-\/1]...d[1]d[0] + p2 * 2\string^e}}
\DoxyCodeLine{13347     \textcolor{comment}{//         = buffer            + p2 * 2\string^e}}
\DoxyCodeLine{13348     \textcolor{comment}{//}}
\DoxyCodeLine{13349     \textcolor{comment}{// Now generate the digits of the fractional part p2 * 2\string^e.}}
\DoxyCodeLine{13350     \textcolor{comment}{//}}
\DoxyCodeLine{13351     \textcolor{comment}{// Note:}}
\DoxyCodeLine{13352     \textcolor{comment}{// No decimal point is generated: the exponent is adjusted instead.}}
\DoxyCodeLine{13353     \textcolor{comment}{//}}
\DoxyCodeLine{13354     \textcolor{comment}{// p2 actually represents the fraction}}
\DoxyCodeLine{13355     \textcolor{comment}{//}}
\DoxyCodeLine{13356     \textcolor{comment}{//      p2 * 2\string^e}}
\DoxyCodeLine{13357     \textcolor{comment}{//          = p2 / 2\string^-\/e}}
\DoxyCodeLine{13358     \textcolor{comment}{//          = d[-\/1] / 10\string^1 + d[-\/2] / 10\string^2 + ...}}
\DoxyCodeLine{13359     \textcolor{comment}{//}}
\DoxyCodeLine{13360     \textcolor{comment}{// Now generate the digits d[-\/m] of p1 from left to right (m = 1,2,...)}}
\DoxyCodeLine{13361     \textcolor{comment}{//}}
\DoxyCodeLine{13362     \textcolor{comment}{//      p2 * 2\string^e = d[-\/1]d[-\/2]...d[-\/m] * 10\string^-\/m}}
\DoxyCodeLine{13363     \textcolor{comment}{//                      + 10\string^-\/m * (d[-\/m-\/1] / 10\string^1 + d[-\/m-\/2] / 10\string^2 + ...)}}
\DoxyCodeLine{13364     \textcolor{comment}{//}}
\DoxyCodeLine{13365     \textcolor{comment}{// using}}
\DoxyCodeLine{13366     \textcolor{comment}{//}}
\DoxyCodeLine{13367     \textcolor{comment}{//      10\string^m * p2 = ((10\string^m * p2) div 2\string^-\/e) * 2\string^-\/e + ((10\string^m * p2) mod 2\string^-\/e)}}
\DoxyCodeLine{13368     \textcolor{comment}{//                = (                   d) * 2\string^-\/e + (                   r)}}
\DoxyCodeLine{13369     \textcolor{comment}{//}}
\DoxyCodeLine{13370     \textcolor{comment}{// or}}
\DoxyCodeLine{13371     \textcolor{comment}{//      10\string^m * p2 * 2\string^e = d + r * 2\string^e}}
\DoxyCodeLine{13372     \textcolor{comment}{//}}
\DoxyCodeLine{13373     \textcolor{comment}{// i.e.}}
\DoxyCodeLine{13374     \textcolor{comment}{//}}
\DoxyCodeLine{13375     \textcolor{comment}{//      M+ = buffer + p2 * 2\string^e}}
\DoxyCodeLine{13376     \textcolor{comment}{//         = buffer + 10\string^-\/m * (d + r * 2\string^e)}}
\DoxyCodeLine{13377     \textcolor{comment}{//         = (buffer * 10\string^m + d) * 10\string^-\/m + 10\string^-\/m * r * 2\string^e}}
\DoxyCodeLine{13378     \textcolor{comment}{//}}
\DoxyCodeLine{13379     \textcolor{comment}{// and stop as soon as 10\string^-\/m * r * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{13380 }
\DoxyCodeLine{13381     assert(p2 > delta);}
\DoxyCodeLine{13382 }
\DoxyCodeLine{13383     \textcolor{keywordtype}{int} m = 0;}
\DoxyCodeLine{13384     \textcolor{keywordflow}{for} (;;)}
\DoxyCodeLine{13385     \{}
\DoxyCodeLine{13386         \textcolor{comment}{// Invariant:}}
\DoxyCodeLine{13387         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (d[-\/m-\/1] / 10 + d[-\/m-\/2] / 10\string^2 + ...) * 2\string^e}}
\DoxyCodeLine{13388         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (p2                                 ) * 2\string^e}}
\DoxyCodeLine{13389         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (10 * p2)                   ) * 2\string^e}}
\DoxyCodeLine{13390         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * ((10*p2 div 2\string^-\/e) * 2\string^-\/e + (10*p2 mod 2\string^-\/e)) * 2\string^e}}
\DoxyCodeLine{13391         \textcolor{comment}{//}}
\DoxyCodeLine{13392         assert(p2 <= (std::numeric\_limits<std::uint64\_t>::max)() / 10);}
\DoxyCodeLine{13393         p2 *= 10;}
\DoxyCodeLine{13394         \textcolor{keyword}{const} std::uint64\_t d = p2 >> -\/one.e;     \textcolor{comment}{// d = (10 * p2) div 2\string^-\/e}}
\DoxyCodeLine{13395         \textcolor{keyword}{const} std::uint64\_t r = p2 \& (one.f -\/ 1); \textcolor{comment}{// r = (10 * p2) mod 2\string^-\/e}}
\DoxyCodeLine{13396         \textcolor{comment}{//}}
\DoxyCodeLine{13397         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d * 2\string^-\/e + r) * 2\string^e}}
\DoxyCodeLine{13398         \textcolor{comment}{//         = buffer * 10\string^-\/m + 10\string^-\/m * (1/10 * (d + r * 2\string^e))}}
\DoxyCodeLine{13399         \textcolor{comment}{//         = (buffer * 10 + d) * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{13400         \textcolor{comment}{//}}
\DoxyCodeLine{13401         assert(d <= 9);}
\DoxyCodeLine{13402         buffer[length++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + d); \textcolor{comment}{// buffer := buffer * 10 + d}}
\DoxyCodeLine{13403         \textcolor{comment}{//}}
\DoxyCodeLine{13404         \textcolor{comment}{//      M+ = buffer * 10\string^(-\/m-\/1) + 10\string^(-\/m-\/1) * r * 2\string^e}}
\DoxyCodeLine{13405         \textcolor{comment}{//}}
\DoxyCodeLine{13406         p2 = r;}
\DoxyCodeLine{13407         m++;}
\DoxyCodeLine{13408         \textcolor{comment}{//}}
\DoxyCodeLine{13409         \textcolor{comment}{//      M+ = buffer * 10\string^-\/m + 10\string^-\/m * p2 * 2\string^e}}
\DoxyCodeLine{13410         \textcolor{comment}{// Invariant restored.}}
\DoxyCodeLine{13411 }
\DoxyCodeLine{13412         \textcolor{comment}{// Check if enough digits have been generated.}}
\DoxyCodeLine{13413         \textcolor{comment}{//}}
\DoxyCodeLine{13414         \textcolor{comment}{//      10\string^-\/m * p2 * 2\string^e <= delta * 2\string^e}}
\DoxyCodeLine{13415         \textcolor{comment}{//              p2 * 2\string^e <= 10\string^m * delta * 2\string^e}}
\DoxyCodeLine{13416         \textcolor{comment}{//                    p2 <= 10\string^m * delta}}
\DoxyCodeLine{13417         delta *= 10;}
\DoxyCodeLine{13418         dist  *= 10;}
\DoxyCodeLine{13419         \textcolor{keywordflow}{if} (p2 <= delta)}
\DoxyCodeLine{13420         \{}
\DoxyCodeLine{13421             \textcolor{keywordflow}{break};}
\DoxyCodeLine{13422         \}}
\DoxyCodeLine{13423     \}}
\DoxyCodeLine{13424 }
\DoxyCodeLine{13425     \textcolor{comment}{// V = buffer * 10\string^-\/m, with M-\/ <= V <= M+.}}
\DoxyCodeLine{13426 }
\DoxyCodeLine{13427     decimal\_exponent -\/= m;}
\DoxyCodeLine{13428 }
\DoxyCodeLine{13429     \textcolor{comment}{// 1 ulp in the decimal representation is now 10\string^-\/m.}}
\DoxyCodeLine{13430     \textcolor{comment}{// Since delta and dist are now scaled by 10\string^m, we need to do the}}
\DoxyCodeLine{13431     \textcolor{comment}{// same with ulp in order to keep the units in sync.}}
\DoxyCodeLine{13432     \textcolor{comment}{//}}
\DoxyCodeLine{13433     \textcolor{comment}{//      10\string^m * 10\string^-\/m = 1 = 2\string^-\/e * 2\string^e = ten\_m * 2\string^e}}
\DoxyCodeLine{13434     \textcolor{comment}{//}}
\DoxyCodeLine{13435     \textcolor{keyword}{const} std::uint64\_t ten\_m = one.f;}
\DoxyCodeLine{13436     grisu2\_round(buffer, length, dist, delta, p2, ten\_m);}
\DoxyCodeLine{13437 }
\DoxyCodeLine{13438     \textcolor{comment}{// By construction this algorithm generates the shortest possible decimal}}
\DoxyCodeLine{13439     \textcolor{comment}{// number (Loitsch, Theorem 6.2) which rounds back to w.}}
\DoxyCodeLine{13440     \textcolor{comment}{// For an input number of precision p, at least}}
\DoxyCodeLine{13441     \textcolor{comment}{//}}
\DoxyCodeLine{13442     \textcolor{comment}{//      N = 1 + ceil(p * log\_10(2))}}
\DoxyCodeLine{13443     \textcolor{comment}{//}}
\DoxyCodeLine{13444     \textcolor{comment}{// decimal digits are sufficient to identify all binary floating-\/point}}
\DoxyCodeLine{13445     \textcolor{comment}{// numbers (Matula, "In-\/and-\/Out conversions").}}
\DoxyCodeLine{13446     \textcolor{comment}{// This implies that the algorithm does not produce more than N decimal}}
\DoxyCodeLine{13447     \textcolor{comment}{// digits.}}
\DoxyCodeLine{13448     \textcolor{comment}{//}}
\DoxyCodeLine{13449     \textcolor{comment}{//      N = 17 for p = 53 (IEEE double precision)}}
\DoxyCodeLine{13450     \textcolor{comment}{//      N = 9  for p = 24 (IEEE single precision)}}
\DoxyCodeLine{13451 \}}

\end{DoxyCode}
